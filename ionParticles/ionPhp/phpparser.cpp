#include "phpparser.h"
#include <antlr3.h>
#include "phpParser/output/ionPhpLexer.h"
#include "phpParser/output/ionPhpParser.h"

#include <iostream>
#include <QVector>

namespace IonPhp {


phpParser::phpParser()
{
}

void print_tree (pANTLR3_BASE_TREE node, int level = 0) {
    if (!node) {
        return;
    }
    if (node->toString) {
        std::cout << std::string((char *)node->toString(node)->chars);
    } else {
        std::cout << " NIL ";
    }
    std::cout << "; ";
    if (int count = node->getChildCount(node)) {
        std::cout << " ( ";
        for (int i=0; i < count; i++) {
            print_tree((pANTLR3_BASE_TREE)node->getChild(node, i));
        }
        std::cout << " ) ";
    }
}

bool phpParser::parse(QString doc, QString name)
{
    //http://www.antlr.org/api/C/buildrec.html


      // The ANTLR3 character input stream, which abstracts the input source such that
      // it is easy to privide inpput from different sources such as files, or
      // memory strings.
      //
      // For an 8Bit/latin-1/etc memory string use:
      //     input = antlr3New8BitStringInPlaceStream (stringtouse, (ANTLR3_UINT32) length, NULL);
      //
      // For a UTF16 memory string use:
      //     input = antlr3NewUTF16StringInPlaceStream (stringtouse, (ANTLR3_UINT32) length, NULL);
      //
    QByteArray p1 = doc.toAscii(), p2 = name.toAscii();

    pANTLR3_INPUT_STREAM input = antlr3StringStreamNew((pANTLR3_UINT8)p1.constData(), ANTLR3_ENC_8BIT, (ANTLR3_UINT32) doc.length(), (pANTLR3_UINT8)p2.constData());

      // The lexer is of course generated by ANTLR, and so the lexer type is not upper case.
      // The lexer is supplied with a pANTLR3_INPUT_STREAM from whence it consumes its
      // input and generates a token stream as output. This is the ctx (CTX macro) pointer
      // for your lexer.
      //
      pionPhpLexer             lxr;

      // The token stream is produced by the ANTLR3 generated lexer. Again it is a structure based
      // API/Object, which you can customise and override methods of as you wish. a Token stream is
      // supplied to the generated parser, and you can write your own token stream and pass this in
      // if you wish.
      //
      pANTLR3_COMMON_TOKEN_STREAM        tstream;

      // The parser produces an AST, which is returned as a member of the return type of
      // the starting rule (any rule can start first of course). This is a generated type
      // based upon the rule we start with.
      //
      ionPhpParser_prog_return     langAST;


      // The tree nodes are managed by a tree adaptor, which doles
      // out the nodes upon request. You can make your own tree types and adaptors
      // and override the built in versions. See runtime source for details and
      // eventually the wiki entry for the C target.
      //
    //  pANTLR3_COMMON_TREE_NODE_STREAM    nodes;

      // Finally, when the parser runs, it will produce an AST that can be traversed by the
      // the tree parser: c.f. LangDumpDecl.g3t This is the ctx (CTX macro) pointer for your
      // tree parser.
      //
//pLangDumpDecl          treePsr;

      // The input will be created successfully, providing that there is enough
      // memory and the file exists etc
      //
      if ( input == NULL )
      {
             ANTLR3_FPRINTF(stderr, "Unable to read input data\n");
      }

      // Our input stream is now open and all set to go, so we can create a new instance of our
      // lexer and set the lexer input to our input stream:
      //  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
      //
      lxr        = ionPhpLexerNew(input);      // CLexerNew is generated by ANTLR

      // Need to check for errors
      //
      if ( lxr == NULL )
      {
             ANTLR3_FPRINTF(stderr, "Unable to create the lexer due to malloc() failure1\n");
             exit(ANTLR3_ERR_NOMEM);
      }

      // Our lexer is in place, so we can create the token stream from it
      // NB: Nothing happens yet other than the file has been read. We are just
      // connecting all these things together and they will be invoked when we
      // call the parser rule. ANTLR3_SIZE_HINT can be left at the default usually
      // unless you have a very large token stream/input. Each generated lexer
      // provides a token source interface, which is the second argument to the
      // token stream creator.
      // Note tha even if you implement your own token structure, it will always
      // contain a standard common token within it and this is the pointer that
      // you pass around to everything else. A common token as a pointer within
      // it that should point to your own outer token structure.
      //
      tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, lxr->pLexer->rec->state->tokSource);

      if (tstream == NULL)
      {
         ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate token stream\n");
         exit(ANTLR3_ERR_NOMEM);
      }

      // Finally, now that we have our lexer constructed, we can create the parser
      //
      // The Lang parser is also generated by ANTLR and accepts a token stream as explained
      // above. The token stream can be any source in fact, so long as it implements the
      // ANTLR3_TOKEN_SOURCE interface. In this case the parser does not return anything
      // but it can of course specify any kind of return type from the rule you invoke
      // when calling it. This is the ctx (CTX macro) pointer for your parser.
      //
      pionPhpParser psr = ionPhpParserNew(tstream);  // CParserNew is generated by ANTLR3

      if (psr == NULL)
      {
         ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate parser\n");
         exit(ANTLR3_ERR_NOMEM);
      }

      // We are all ready to go. Though that looked complicated at first glance,
      // I am sure, you will see that in fact most of the code above is dealing
      // with errors and there isn;t really that much to do (isn;t this always the
      // case in C? ;-).
      //
      // So, we now invoke the parser. All elements of ANTLR3 generated C components
      // as well as the ANTLR C runtime library itself are pseudo objects. This means
      // that they are represented as pointers to structures, which contain any
      // instance data they need, and a set of pointers to other interfaces or
      // 'methods'. Note that in general, these few pointers we have created here are
      // the only things you will ever explicitly free() as everything else is created
      // via factories, that allocate memory efficiently and free() everything they use
      // automatically when you close the parser/lexer/etc.
      //
      // Note that this means only that the methods are always called via the object
      // pointer and the first argument to any method, is a pointer to the structure itself.
      // It also has the side advantage, if you are using an IDE such as VS2005 that can do it
      // that when you type ->, you will see a list of all the methods the object supports.
      //
      ionPhpParserOptions.state = TEXT;
      langAST = psr->prog(psr);

      // If the parser ran correctly, we will have a tree to parse. In general I recommend
      // keeping your own flags as part of the error trapping, but here is how you can
      // work out if there were errors if you are using the generic error messages
      //
      bool success = !(psr->pParser->rec->state->errorCount > 0);
     if (!success)
     {
         ANTLR3_FPRINTF(stderr, "The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount);

     }
     else
     {
         print_tree((pANTLR3_BASE_TREE)langAST.tree);
         //nodes   = antlr3CommonTreeNodeStreamNewTree(langAST.tree, ANTLR3_SIZE_HINT); // sIZE HINT WILL SOON BE DEPRECATED!!
//toStringTree.
         // Tree parsers are given a common tree node stream (or your override)
         //
//         treePsr = LangDumpDeclNew(nodes);

//         treePsr->decl(treePsr);
//

         //nodes   ->free  (nodes);        nodes   = NULL;
//         treePsr ->free  (treePsr);      treePsr = NULL;
     }

     // We did not return anything from this parser rule, so we can finish. It only remains
     // to close down our open objects, in the reverse order we created them
     //
     psr     ->free  (psr);      psr     = NULL;
     tstream ->free  (tstream);  tstream = NULL;
     lxr     ->free  (lxr);      lxr     = NULL;
     input   ->close (input);    input   = NULL;

      return success;
}

}
